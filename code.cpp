/*
 *  code.cpp
 *
 *  Created on: Oct 30, 2015
 *      Author: Naman, Srishti
 *
 * Play with parameters
 * preprocess - BG Subt -> threshold [OTSU] -> morph -> contour = shows circles in contours
 * Face detect -> remove with flood fill -> skin -> contour
 * Hand Detection with haar -> bounding box -> contouring within box = shows circles in contours
 */

#include <_mingw.h>
#include <core/cvdef.h>
#include <core/cvstd.hpp>
#include <core/mat.hpp>
#include <core/mat.inl.hpp>
#include <core/matx.hpp>
#include <core/ptr.inl.hpp>
#include <core/types.hpp>
#include <core.hpp>
#include <highgui.hpp>
#include <imgproc/types_c.h>
#include <imgproc.hpp>
#include <objdetect.hpp>
#include <video/background_segm.hpp>
#include <videoio.hpp>
#include <algorithm>
#include <cmath>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

using namespace cv;
using namespace std;

Mat frame;                                      //current frame
Mat fgMaskMOG2;                       //fg mask fg mask generated by MOG2 method
Mat back;                                       //stores the background frame
Ptr<BackgroundSubtractorMOG2> pMOG2;            //MOG2 Background subtractor
vector<pair<Point, double>> palm_centers;       //store last 10 palm centers
Mat draw;                                       //Mat for drawing
vector<Point> points;


//String face_cascade_name =
//    "../../../data/haarcascades/haarcascade_frontalface_alt.xml";

String face_cascade_name =
    "haarcascade_frontalface_alt.xml";

//String face_cascade_name = "../../../data/haarcascades/aGest.xml";
CascadeClassifier face_cascade;

//This function returns the square of the euclidean distance between 2 points.
double dist(Point x, Point y) {
  return (x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y);
}

Mat pre_processing(Mat frame) {

  GaussianBlur(frame, frame, Size(7, 7), 10, 10);
  Mat gray_scale;
  cvtColor(frame, gray_scale, COLOR_BGR2GRAY, 1);

  Mat element = (Mat_<uchar>(3, 3) << 0, 1, 0, 1, 1, 1, 0, 1, 0);
  morphologyEx(gray_scale, gray_scale, MORPH_OPEN, element);

  return gray_scale;
}

void bg_subtraction(VideoCapture cap, Mat frame) {

  //update the background model
  pMOG2->apply(frame, fgMaskMOG2);

  //Get background image to display it
  pMOG2->getBackgroundImage(back);
  pMOG2->setDetectShadows(0);
  pMOG2->setNMixtures(3);
}

//This function returns the radius and the center of the circle given 3 points
//If a circle cannot be formed , it returns a zero radius circle centered at (0,0)
pair<Point, double> circleFromPoints(Point p1, Point p2, Point p3) {
  double offset = pow(p2.x, 2) + pow(p2.y, 2);
  double bc = (pow(p1.x, 2) + pow(p1.y, 2) - offset) / 2.0;
  double cd = (offset - pow(p3.x, 2) - pow(p3.y, 2)) / 2.0;
  double det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);
  double TOL = 0.0000001;

  if (abs(det) < TOL) {
    cout << "POINTS TOO CLOSE" << endl;
    return make_pair(Point(0, 0), 0);
  }

  double idet = 1 / det;
  double centerx = (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
  double centery = (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
  double radius = sqrt(pow(p2.x - centerx, 2) + pow(p2.y - centery, 2));

  return make_pair(Point(centerx, centery), radius);
}

Mat contouring(Mat binarized, Mat pre_processed) {
  vector<vector<Point>> contours;
  findContours(binarized, contours, CV_RETR_EXTERNAL,
      CV_CHAIN_APPROX_TC89_KCOS);

  for (int i = 0; i < contours.size(); i++)

    //Ignore all small insignificant areas
    if (contourArea(contours[i]) >= 5000) {

      //Draw contour
      vector<vector<Point>> tcontours;
      tcontours.push_back(contours[i]);
      drawContours(pre_processed, tcontours, -1, Scalar(0, 0, 255), 2);

      //Detect Hull in current contour
      vector<vector<Point> > hulls(1);
      vector<vector<int> > hullsI(1);
      convexHull(Mat(tcontours[0]), hulls[0], false);
      convexHull(Mat(tcontours[0]), hullsI[0], false);
      drawContours(pre_processed, hulls, -1, Scalar(0, 255, 0), 2);

      //Find minimum area rectangle to enclose hand
      RotatedRect rect = minAreaRect(Mat(tcontours[0]));

      //Find Convex Defects
      vector<Vec4i> defects;
      if (hullsI[0].size() > 0) {
        Point2f rect_points[4];
        rect.points(rect_points);
        for (int j = 0; j < 4; j++)
          line(pre_processed, rect_points[j], rect_points[(j + 1) % 4],
              Scalar(255, 0, 0), 1, 8);
        Point rough_palm_center;
        convexityDefects(tcontours[0], hullsI[0], defects);
        if (defects.size() >= 3) {
          vector<Point> palm_points;
          for (int j = 0; j < defects.size(); j++) {
            int startidx = defects[j][0];
            Point ptStart(tcontours[0][startidx]);
            int endidx = defects[j][1];
            Point ptEnd(tcontours[0][endidx]);
            int faridx = defects[j][2];
            Point ptFar(tcontours[0][faridx]);

            //Sum up all the hull and defect points to compute average
            rough_palm_center += ptFar + ptStart + ptEnd;
            palm_points.push_back(ptFar);
            palm_points.push_back(ptStart);
            palm_points.push_back(ptEnd);
          }

          //Get palm center by 1st getting the average of all defect points, this is the rough palm center,
          //Then chose the closest 3 points ang get the circle radius and center formed from them which is the palm center.
          rough_palm_center.x /= defects.size() * 3;
          rough_palm_center.y /= defects.size() * 3;
          Point closest_pt = palm_points[0];
          vector<pair<double, int> > distvec;
          for (int i = 0; i < palm_points.size(); i++)
            distvec.push_back(
                make_pair(dist(rough_palm_center, palm_points[i]), i));
          sort(distvec.begin(), distvec.end());

          //Keep choosing 3 points till you find a circle with a valid radius
          //As there is a high chance that the closes points might be in a linear line or too close that it forms a very large circle
          pair<Point, double> soln_circle;
          for (int i = 0; i + 2 < distvec.size(); i++) {
            Point p1 = palm_points[distvec[i + 0].second];
            Point p2 = palm_points[distvec[i + 1].second];
            Point p3 = palm_points[distvec[i + 2].second];
            soln_circle = circleFromPoints(p1, p2, p3); //Final palm center,radius
            if (soln_circle.second != 0)
              break;
          }

          //Find avg palm centers for the last few frames to stabilize its centers, also find the avg radius
          palm_centers.push_back(soln_circle);
          if (palm_centers.size() > 10)
            palm_centers.erase(palm_centers.begin());

          Point palm_center;
          double radius = 0;

          //averaging all palm centres
          for (int i = 0; i < palm_centers.size(); i++) {
            palm_center += palm_centers[i].first;
            radius += palm_centers[i].second;
          }
          palm_center.x /= palm_centers.size();
          palm_center.y /= palm_centers.size();
          radius /= palm_centers.size();

          //Draw the palm center and the palm circle
          //The size of the palm gives the depth of the hand
          circle(pre_processed, palm_center, 5, Scalar(144, 144, 255), 3);
          circle(pre_processed, palm_center, radius, Scalar(144, 144, 255), 2);

          //Detect fingers by finding points that form an almost isosceles triangle with certain thesholds
          int no_of_fingers = 0;
          for (int j = 0; j < defects.size(); j++) {
            int startidx = defects[j][0];
            Point ptStart(tcontours[0][startidx]);
            int endidx = defects[j][1];
            Point ptEnd(tcontours[0][endidx]);
            int faridx = defects[j][2];
            Point ptFar(tcontours[0][faridx]);

            //X o--------------------------o Y

            double Xdist = sqrt(dist(palm_center, ptFar));
            double Ydist = sqrt(dist(palm_center, ptStart));
            double length = sqrt(dist(ptFar, ptStart));
            double retLength = sqrt(dist(ptEnd, ptFar));

            //Play with these thresholds to improve performance
            if (length <= 3 * radius && Ydist >= 0.4 * radius && length >= 10
                && retLength >= 10
                && max(length, retLength) / min(length, retLength) >= 0.8) {
              if (min(Xdist, Ydist) / max(Xdist, Ydist) <= 0.8) {
                if ((Xdist >= 0.1 * radius && Xdist <= 1.3 * radius
                    && Xdist < Ydist)
                    || (Ydist >= 0.1 * radius && Ydist <= 1.3 * radius
                        && Xdist > Ydist)) {
                  line(pre_processed, ptEnd, ptFar, Scalar(0, 255, 0), 1);
                  no_of_fingers++;
                }
              }
            }
          }

          no_of_fingers = min(5, no_of_fingers);
          cout << "NO OF FINGERS: " << no_of_fingers << endl;

          putText(pre_processed, "NO OF FINGERS: " + to_string(no_of_fingers),
              Point(30, 30), FONT_HERSHEY_COMPLEX_SMALL, 0.8,
              Scalar(200, 200, 250), 1, LINE_AA);


          if (no_of_fingers == 1) {
            //draw on draw matrix

            circle(draw, palm_center, 2, Scalar(0, 0, 255), 2);

            if(!points.empty())
              line(draw, palm_center, points.back() ,Scalar(14, 174, 255), 2);

            points.push_back(palm_center);

//            imshow("draw", draw);
          }else if(no_of_fingers == 5){
            putText(pre_processed, "PAN GESTURE",
                Point(90, 90), FONT_HERSHEY_COMPLEX_SMALL, 0.8,
                Scalar(200, 200, 250), 1, LINE_AA);

          }
        }
      }
    }
  return pre_processed;
}

void facedetect(Mat frame) {
  vector<Rect> faces;
  Mat frame_gray;

  if (frame.channels() > 1)
    cvtColor(frame, frame_gray, COLOR_BGR2GRAY);
  else
    frame_gray = frame;

  equalizeHist(frame_gray, frame_gray);

  //Detect faces
  face_cascade.detectMultiScale(frame_gray, faces, 1.1, 2,
      0 | CASCADE_SCALE_IMAGE, Size(30, 30));

  for (size_t i = 0; i < faces.size(); i++) {
    Point center(faces[i].x + faces[i].width / 2,
        faces[i].y + faces[i].height / 2);
    ellipse(frame, center, Size(faces[i].width / 2, faces[i].height / 2), 0, 0,
        360, Scalar(0, 0, 0), 200, 8, 0);

    Mat faceROI = frame_gray(faces[i]);
  }
}

Mat skin_detect(Mat frame) {

  //blur the image to make segmentation simpler
  blur(frame, frame, Size(10, 10));

  //convert the image from bgr to hsv mode
  Mat hsv;
  cvtColor(frame, hsv, CV_BGR2HSV);

  Mat detected;

  //lower bound - Scalar(0, 10, 60)  and upper bound - Scalar(20, 150, 255) for classifying skin
  //ranged is set to 255 (skin) if hsv is within the specified range and 0 otherwise.
  inRange(hsv, Scalar(0, 10, 60), Scalar(20, 150, 255), detected);

  return detected;
}

int process_video() {

  VideoCapture cap(0); // open the default camera
  if (!cap.isOpened())  // check if we succeeded
    return -1;

  //draw on blackboard
  Size s = Size(640, 480);
  draw = Mat::zeros(s, CV_8UC3);

  for (;;) {
    cap >> frame; // get a new frame from camera
    Mat orig = frame.clone();

    Mat foreground;

    Mat pre_processed = pre_processing(frame); //preprocess and convert to grayscale

    //returns the bg subtracted and stores
    bg_subtraction(cap, pre_processed);

    absdiff(pre_processed, back, foreground);


    Mat temp = foreground.clone();
//    facedetect(temp);

    Mat fg_binarized_mask;
    threshold(temp, fg_binarized_mask, 0, 255,
        THRESH_BINARY | THRESH_OTSU);
    GaussianBlur(fg_binarized_mask, fg_binarized_mask, Size(7, 7), 10, 10);

    //morphology to remove noise
    Mat element = (Mat_<uchar>(3, 3) << 0, 1, 0, 1, 1, 1, 0, 1, 0);
    morphologyEx(fg_binarized_mask, fg_binarized_mask, MORPH_OPEN, element);

    Mat bg_removed;
    orig.copyTo(bg_removed,fg_binarized_mask);

//    imshow("Binarised", fg_binarized_mask);

    //Detect Face here and remove it, input would be result of the above step


    /*
       //only hand is left detect skin
      Mat a = skin_detect(bg_removed);
      imshow("bg removed gray", a);
     */

    //finally contour
    Mat contour = contouring(fg_binarized_mask, bg_removed);

    imshow("Output", contour);
    imshow("Board", draw);
    if (waitKey(30) >= 0)
      break;
  }
  return 0;
}

int main(int, char**) {

  //create Background Subtractor objects
  pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
   // Load the cascades
   if( !face_cascade.load( face_cascade_name ) ){ printf("--(!)Error loading face cascade\n"); return -1; };

  int res = process_video();
  return 0;
}
